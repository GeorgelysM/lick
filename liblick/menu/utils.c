#include <dirent.h>
#include <stdlib.h>
#include <string.h>

#include "utils.h"
#include "../install.h"
#include "../utils.h"

entry_t *new_entry() {
    entry_t *e = malloc(sizeof(entry_t));
    e->title = NULL;
    e->kernel = NULL;
    e->initrd = NULL;
    e->options = NULL;
    e->static_text = NULL;
    return e;
}

entry_t *get_entry(FILE *f) {
    entry_t *e = NULL;
    fpos_t pos;

    while(1) {
        fgetpos(f, &pos);
        char *ln = read_line(f);
        if(ln == NULL)
            break;

        char *keyword_start;
        char *item_start;
        conf_option(ln, &keyword_start, &item_start);

        if(keyword_start == NULL) { // nothing found
            free(ln);
            continue;
        } else if(item_start == NULL)
			item_start = "";

        enum type_e {
            TITLE,
            KERNEL,
            INITRD,
            OPTIONS,
            STATIC,
        } type;

        if(strcmp(keyword_start, "title") == 0)
            type = TITLE;
        else if(strcmp(keyword_start, "kernel") == 0)
            type = KERNEL;
        else if(strcmp(keyword_start, "initrd") == 0)
            type = INITRD;
        else if(strcmp(keyword_start, "options") == 0)
            type = OPTIONS;
        else if(strcmp(keyword_start, "static") == 0)
            type = STATIC;
        else {
            free(ln);
            continue;
        }

        if(e == NULL)
            e = new_entry();

        char **target;
        switch(type) {
            case TITLE:
                target = &(e->title);
                break;
            case KERNEL:
                target = &(e->kernel);
                break;
            case INITRD:
                target = &(e->initrd);
                break;
            case OPTIONS:
                target = &(e->options);
                break;
            case STATIC:
                target = &(e->static_text);
                break;
        }

        // if item already found, current entry complete; unread line
        if(*target != NULL) {
            free(ln);
            if(!fsetpos(f, &pos)) {
                // unlikely to happen
                free(e);
                return NULL;
            }
            return e;
        }

        *target = strdup2(item_start);
        free(ln);

        if((e->title && e->kernel && e->initrd && e->options) || e->static_text)
            return e;
    }

    return e;
}

void free_entry(entry_t *e) {
    if(e == NULL)
        return;
    if(e->title)
        free(e->title);
    if(e->kernel)
        free(e->kernel);
    if(e->initrd)
        free(e->initrd);
    if(e->options)
        free(e->options);
    if(e->static_text)
        free(e->static_text);
    free(e);
}

char *to_menu_path(const char *path) {
    const char *start = path;
    const char *colon = strchr(path, ':');
    if(colon != NULL)
        start = colon + 1;

    return unix_path(strdup2(start));
}

void write_menu(lickdir_t *lick, FILE *menu,
        void (*write)(FILE *, entry_t *)) {
    fprintf(menu, "# This file was generated by LICK.\n");
    fprintf(menu, "# DO NOT MODIFY THIS FILE DIRECTLY.\n");

    node_t *files = get_conf_files(lick->menu);
    for(node_t *n = files; n != NULL; n = n->next) {
        FILE *f = fopen(n->val, "r");
        if(!f)
            continue;
        while(1) {
            entry_t *e = get_entry(f);
            if(e == NULL)
                break;
            write(menu, e);
            free_entry(e);
        }
        fclose(f);
    }

    free_list(files, free);
}
